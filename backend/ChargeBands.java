package backend;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.Duration;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.util.List;
import net.proteanit.sql.DbUtils;


public class ChargeBands {

	//the statement to use the query as parameter
	static PreparedStatement stmt = null;
	//result set generated by statement
	static ResultSet rs = null;
	
	/**
     * A method to add a review to a certain property
     *
     * @param int propertyID, the propertys PK
     * @param int pricePerNight, the price per night in this band
     * @param int serviceCharge, the serviceCharge in this period
     * @param int cleaningCharge, the charge for cleaning in this period
     * @param int dayStart, the day of the start date
     * @param int monthStart, the month of the start date
     * @param int yearStart, the year of the start date
     * @param int dayEnd, the day of the end date
     * @param int monthEnd, the month of the end date
     * @param int yearEnd, the year of the end date
     */
	public static void addChargeBand(int propertyID, int pricePerNight, int serviceCharge, int cleaningCharge, int dayStart,
			int monthStart, int yearStart, int dayEnd, int monthEnd, int yearEnd) throws Exception {
		
		String startDateFormat = yearStart + "-" + monthStart + "-" + dayStart;
		String endDateFormat = yearEnd + "-" + monthEnd + "-" + dayEnd;
		Date startDate = Date.valueOf(startDateFormat);
		Date endDate = Date.valueOf(endDateFormat);
		int number = viewLatestChargeBandID() + 1;
		
		Connection con = DBAccess.connect();
		String query = "INSERT INTO ChargeBands (chargeBand,propertyID,startDate,endDate,pricePerNight,serviceCharge,cleaningCharge) "
				+ "VALUES ('" + number + "','" + propertyID + "','" + startDate + "','" + endDate + "','" + pricePerNight + "','" + serviceCharge + "','" + cleaningCharge + "')";
		//Create statement with try-catch block
		try {
			stmt = con.prepareStatement(query);
			stmt.executeUpdate();
			System.out.println("Charge band between " + startDate + " and " + endDate + " added to property " + propertyID);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		
		DBAccess.disconnect();
	}
	
	/**
     * A method to update the start date of a property's charge band
     *
     * @param int dayStart, the day of the start date
     * @param int monthStart, the month of the start date
     * @param int yearStart, the year of the start date
     */
	public static void editChargeBandStartDate(int propertyID, int dayStart,
			int monthStart, int yearStart) throws Exception {
		
		String startDateFormat = yearStart + "-" + monthStart + "-" + dayStart;
		Date startDate = Date.valueOf(startDateFormat);
		int number = viewLatestChargeBandID() + 1;
		
		Connection con = DBAccess.connect();
		String query = "UPDATE ChargeBands SET startDate='" + startDate + "' WHERE propertyID ='" + propertyID + "'";
		//Create statement with try-catch block
		try {
			stmt = con.prepareStatement(query);
			stmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		
		DBAccess.disconnect();
	}
	
	/**
     * A method to update the end date of a property's charge band
     *
     * @param int dayEnd, the day of the end date
     * @param int monthEnd, the month of the end date
     * @param int yearEnd, the year of the end date
     */
	public static void editChargeBandEndDate(int propertyID, int dayEnd,
			int monthEnd, int yearEnd) throws Exception {
		
		String endDateFormat = yearEnd + "-" + monthEnd + "-" + dayEnd;
		Date endDate = Date.valueOf(endDateFormat);
		int number = viewLatestChargeBandID() + 1;
		
		Connection con = DBAccess.connect();
		String query = "UPDATE ChargeBands SET endDate='" + endDate + "' WHERE propertyID ='" + propertyID + "'";
		//Create statement with try-catch block
		try {
			stmt = con.prepareStatement(query);
			stmt.executeUpdate();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		
		DBAccess.disconnect();
	}
	
	
	/**
     * A 'get' method for retrieving the general location of a property. This is only the city and postcode.
     * Confidential location (next method) is to be released when parties agree on the booking.
     *
     * @param int propertyID, the properties specific ID
     * @param String columnName, the feature assignment of the property to be changed
     * @return String newValue, the new value to be replacing the old in the specific feature.
     */
	public static void editChargeBand(int propertyID, String columnName, String newValue) throws Exception {
		
		Connection con = DBAccess.connect();
		if (columnName == "pricePerNight" || columnName == "serviceCharge" || columnName == "cleaningCharge" ) {
			int newValueInt = Integer.parseInt(newValue);
			String query = "UPDATE ChargeBands SET " + columnName + "='" + newValueInt + "' WHERE propertyID ='" + propertyID + "'";
			//Create statement with try-catch block
			try {
				stmt = con.prepareStatement(query);
				stmt.executeUpdate(query);
				System.out.println("Charge Band for property " + propertyID + "'s " + columnName + " has been updated to " + newValue);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		} else {
			String query = "UPDATE ChargeBands SET " + columnName + "='" + newValue + "' WHERE propertyID ='" + propertyID + "'";
			//Create statement with try-catch block
			try {
				stmt = con.prepareStatement(query);
				stmt.executeUpdate(query);
				System.out.println("Charge Band for property " + propertyID + "'s " + columnName + " has been updated to " + newValue);
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		
		DBAccess.disconnect();
	
	}
	
	/**
     * A method to return all the charge bands of a certain property in a list
     * @param propertyID, the PK
     * @param day, the day of the start date
     * @param month, the month of the start date
     * @param year, the year of the start date
     * @return a list of charge bands for the property
	 * @throws Exception if no charge band is found
     */
	public static Integer getPrice(int propertyID, int day, int month, int year, int eDay, int eMonth, int eYear) throws Exception {
		
		String query = "SELECT * FROM ChargeBands WHERE propertyID ='" + propertyID + "'";
		
		String dateFormat = year + "-" + month + "-" + day;
		Date date = Date.valueOf(dateFormat);
		Connection con = DBAccess.connect();
		int toReturn = 0;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				Date sDate = rs.getDate("startDate");
				Date eDate = rs.getDate("endDate");
				if (date.after(sDate) && date.before(eDate)) {
					LocalDate theirStart = LocalDate.of(year, month, day);
					LocalDate theirEnd = LocalDate.of(eYear, eMonth, eDay);
					int pricePerNight = rs.getInt("pricePerNight");
					int serviceCharge = rs.getInt("serviceCharge");
					int cleaningCharge = rs.getInt("cleaningCharge");
					//need to find a solution for this, currently incorrect.
					int daysBetween = (int) Duration.between(theirStart.atStartOfDay(), theirEnd.atStartOfDay()).toDays();
					int total = (int) (daysBetween*pricePerNight) + serviceCharge + cleaningCharge;
					return total;
				}
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		if (toReturn == 0) {
			throw new Exception("No charge band found for this date");
		}
		DBAccess.disconnect();
		return toReturn;
	}
	
	/**
     * A 'get' method for retrieving start date of a property using their PK
     *
     * @param Integer propertyID, the property's ID
     * @return Integer startDay
     */
	public static Date getStartDate(int propertyID)  {
		
		String query = "SELECT startDate FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
		Date date = null;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				date = rs.getDate("startDate");
				
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return date;
		
	}
	
	/**
     * A 'get' method for retrieving end date of a property using their PK
     *
     * @param Integer propertyID, the property's ID
     * @return Integer endDay
     */
	public static Date getEndDate(int propertyID)  {
		
		String query = "SELECT endDate FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
		Date date = null;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				date = rs.getDate("endDate");
				return date;
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return date;
		
	}
	
	/**
     * A 'get' method for retrieving account type of a person using their PK
     *
     * @param Integer propertyID, the property's ID
     * @return Integer price, the price per night
     */
	public static Integer getPricePerNight(int propertyID)  {
		
		String query = "SELECT pricePerNight FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
		int price = 0;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				price = rs.getInt("pricePerNight");
				return price;
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return price;
		
	}
	
	/**
     * A 'get' method for retrieving account type of a person using their PK
     *
     * @param Integer propertyID, the property's ID
     * @return Integer service, the service charge
     */
	public static Integer getServiceCharge(int propertyID)  {
		
		String query = "SELECT serviceCharge FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
		int service = 0;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				service = rs.getInt("serviceCharge");
				return service;
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return service;
		
	}
	
	/**
     * A 'get' method for retrieving account type of a person using their PK
     *
     * @param Integer propertyID, the property's ID
     * @return Integer cleaning, the cleaning charge
     */
	public static Integer getCleaningCharge(int propertyID)  {
		
		String query = "SELECT cleaningCharge FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
		int cleaning = 0;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				cleaning = rs.getInt("cleaningCharge");
				return cleaning;
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return cleaning;
		
	}
	
	
	
	/**
     * A 'get' method for retrieving if the property has an satellite
     *
     * @param int propertyID, the properties specific ID
     * @return boolean toReturn, true if property has a charge band
     */
	public static boolean hasChargeBand(int propertyID) {
		
		String query = "SELECT pricePerNight FROM ChargeBands" + " WHERE propertyID = '" + propertyID + "'";;
		Connection con = DBAccess.connect();
		int newHas = 0;
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				int has = rs.getInt("pricePerNight");
				if (has>=0) {
					newHas = 1;
				}
				return ChargeBands.toBoolean(newHas);
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return false;
		
	}
	
	/**
     * A 'get' method for a hosts result set in properties
     *
     * @param int hostID, the hosts specific ID
     * @return ResultSet rs, the result set containing the hosts properties info
     */
	public static ResultSet getChargeBandResultSet(int propertyID) {
		
		String query = "SELECT propertyID,pricePerNight,serviceCharge,cleaningCharge FROM ChargeBands" + " WHERE propertyID = '" + propertyID + "'";
		Connection con = DBAccess.connect();
        try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			return rs;
			
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		return rs;
	}
	
	/**
     * A method to return all the charge bands of a certain property in a list
     * @param propertyID, the PK
     * @return a list of charge bands for the property
     */
	public static List<String> getChargeBand(int propertyID) {
		
		String query = "SELECT * FROM ChargeBands WHERE propertyID ='" + propertyID + "'";
		Connection con = DBAccess.connect();
		List<String> toReturn = new ArrayList<>();
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				String bandToAdd = "";
				Date startDate = rs.getDate("startDate");
				Date endDate = rs.getDate("endDate");
				int pricePerNight = rs.getInt("pricePerNight");
				int serviceCharge = rs.getInt("serviceCharge");
				int cleaningCharge = rs.getInt("cleaningCharge");
				bandToAdd = "Between the dates " + startDate + " and " + endDate + ": Price Per Night = " + pricePerNight + " Service Charge = " + 
						serviceCharge + " Cleaning Charge = " + cleaningCharge;
				toReturn.add(bandToAdd);
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return toReturn;
	}
	
	public static void deleteChargeBands(int propertyID) throws Exception {
		
		Connection con = DBAccess.connect();
		String query = "DELETE FROM ChargeBands WHERE propertyID = '" + propertyID + "'";
		//Create statement with try-catch block
		try {
			stmt = con.prepareStatement(query);
			stmt.executeUpdate();
			System.out.println("Charge Bands for " + propertyID + " have been deleted." );
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		DBAccess.disconnect();
	
	}
	
	/**
     * This is a helper function for finding out the latest property ID. This allows it so when a property is made,
     * it will automatically be assigned the latest property ID +1
     *
     * @return int latestID, the number of the highest property ID.
     */
	public static int viewLatestChargeBandID() {
		
		String query = "SELECT chargeBand FROM ChargeBands";
		int latestID = 0;
		Connection con = DBAccess.connect();
		//Create statement with try-catch block
		try  {
			stmt = con.prepareStatement(query);
			rs = stmt.executeQuery();
			//means, whilst the result has another row
			while (rs.next()) {
				int ID = rs.getInt("chargeBand");
				if (latestID < ID) {
					latestID = ID;
				}
			}
		} catch (SQLException ex) {
			ex.printStackTrace();
		}
		
		DBAccess.disconnect();
		return latestID;
	}
	

	/**
     * A method to change a boolean value to a tiny int, to avoid confusion when adding properties
     *
     * @param boolean i, the boolean to be converted
     * @return toReturn, corresponding value of 1 (true) or 0 (false)
     */
	public static int toTinyInt(boolean i) throws IllegalArgumentException {
		if (!(i == true || i == false)) {throw new IllegalArgumentException("Value must be true or false");}
		int toReturn = 0;
		if (i == true) {
			return 1;
		}
		return toReturn;
	}
	
	/**
     * method to change an int to a boolean value, to avoid confusion again and to use in methods
     *
     * @param int i, to be converted
     * @return toReturn, corresponding value of true (1) or false (0)
     */
	public static boolean toBoolean(int i) throws IllegalArgumentException {
		if (!(i == 1 || i == 0)) {throw new IllegalArgumentException("Value must be 1 or 0");}
		boolean toReturn = false;
		if (i == 1) {
			return true;
		}
		return toReturn;
	}
		
	//This main method is just to demonstrate how everything works :)
	public static void main(String[] args) throws Exception {
		/*
		Person.addPerson("@test.co.uk", "Mr", "Test", "Man", "HOST", "07958484745", "Test123");
		Properties.addProperty("@test.co.uk", "crazy building", "This building is mint", true, 69, "castle1", "sheffield lane",
				"sheffield", "s10 5bh", true, true, true, true, true, true);
		addChargeBand(Properties.getHostsProperties("@test.co.uk").get(0), 100, 50, 25, 22, 9, 2021, 23, 11, 2021);
		addChargeBand(Properties.getHostsProperties("@test.co.uk").get(0), 100, 50, 25, 22, 9, 2023, 23, 11, 2023);
		System.out.println(getPrice(Properties.getHostsProperties("@test.co.uk").get(0), 24, 9, 2021, 30, 9, 2021));
		Person.deletePerson("@test.co.uk");
		*/
		//addChargeBand(Properties.getHostsProperties("@test.co.uk").get(0), 100, 50, 25, 22, 9, 2023, 23, 11, 2023);
	
		//System.out.println(sy1);
		//System.out.println(String.valueOf(sy1)+String.valueOf(sy2)+String.valueOf(sy3)+String.valueOf(sy4));
		
		
	}
	
}
